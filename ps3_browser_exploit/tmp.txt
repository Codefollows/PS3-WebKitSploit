a lot of stuff is starting to make sense now.. like the memory management for instance
when we call the browser we are in vsh process 32bit memory space..
vsh .text segment is loaded at 0x10000 as always in any process space... an eboot would load at the same address in its own process space as well
additional .text segments from loaded modules, .data & .bss get loaded in this area up to 0x1FFFFFFF
then at 0x20000000 the process heap space begins
the heap is variable of course & above it is the User map area... That's where the js variables & browser data is found...
above 0x80000000 with browser loaded, it could be different with another app
User map area ends at 0xBFFFFFFF & at 0xC0000000 you get the RSX memory
at 0xD0000000 you get the User Stack
and from 0xE0000000 it's SPU specific spaces, Raw SPU & the SPU threads inaccessible by PPU.
the User stack area is protected RW so it cannot be exploited...
same thing goes for any executable areas
so an overflow would not help
one self = one process space
that is why most of the OS parts are implemented as prx
that can be loaded into a self process space
the SCE signature check makes it impossible to load a custom prx, newly made or even patched..
and prx is the only type of executable code the process can launch
it's quite foolproof security wise
if we could only find a way to trigger debug mode though
we could load any resigned prx







I need a std (or stw but std better) gadget
something that would copy to the stack
so the second register will be r1
something like this 
std rXX, 0xYY(r1)
usual requirements for gadgets
ld         r0,0xXY(r1)
addi       r1,r1,0xYX (line might be optional depending on next gadget value for 0xXY)
mtspr      ctr/lr,r0
blr/bctr/bctrl


like 0x80(r1)/0x88(r1) etc.....
the save index is shown as 0xYY

only rXX, 0xYY, 0xXY & 0xYX can vary, nothing else


regex: 

std        r[0123456789][0123456789],0x[0123456789abcdef][0123456789abcdef]\(r1\)

std        r\d\d,0x\d\d\(r1\)












I will also need an alternative gadget 9
to do
lwz        r4,0xXX(r1)
lwz        r3,0xTT(r1)
or ld instead of lwz....

ld/lwz        r4,0xXX(r1)
ld/lwz        r3,0xTT(r1)
ld           r0, 0xXX(r1)
mtlr/mtctr    r0addi         r1, r1, 0xYYblr/bctr
basically like this with usual requirements










Ok this is the list of DEX offsets we need for this chain.. Please grab their CEX equivalent...

0x0976BC
0x6161B8
0x1A43FC
0x0DEBD8
0x434368
0x638214
0x42B708
